[{"content":"Programa√ß√£o orientada a objetos JavaScript √© uma linguagem de programa√ß√£o baseada em prot√≥tipos (prototype-based language), onde propriedades e m√©todos podem ser compartilhadas entre objetos.\nEm JavaScript, tudo funciona como um objeto, exceto os valores null e undefined. Um erro comum √© acreditar que n√∫meros inteiros (literais) n√£o podem ser usados como objetos, pois o ponto . faz com que o interpretador o interprete como um n√∫mero de ponto flutuante.\n123.toString(); // produz um erro de sintaxe  (123).toString(); // \u0026#34;123\u0026#34; 123.0.toString(); // \u0026#34;123\u0026#34; 123..toString(); // \u0026#34;123\u0026#34; 123 .toString(); // \u0026#34;123\u0026#34; Implementa√ß√£o com prototype Veremos um exemplo que faz uso do prototype para compartilhar propriedades e m√©todos entre objetos descendentes, em outras palavras, heran√ßa. Para isso, criaremos tr√™s fun√ß√µes construtoras, a primeira, Coordenada2D, que ser√° usada como base para as outras duas, Retangulo e Circulo.\nfunction Coordenada2D(x, y) { this.tipo = \u0026#34;Coordenada 2D\u0026#34;; this.x = x; this.y = y; } function Retangulo(x, y, base, altura) { Coordenada2D.call(this, x, y); this.tipo = \u0026#34;Ret√¢ngulo\u0026#34;; this.base = base; this.altura = altura; } function Circulo(x, y, raio) { Coordenada2D.call(this, x, y); this.tipo = \u0026#34;C√≠rculo\u0026#34;; this.raio = raio; } Na sequ√™ncia, s√£o criadas as rela√ß√µes de heran√ßa entre o prototype de Coordenada2D e o prototype de Retangulo e Circulo.\nRetangulo.prototype = Object.create(Coordenada2D.prototype); Circulo.prototype = Object.create(Coordenada2D.prototype); Ap√≥s a defini√ß√£o da rela√ß√£o de heran√ßa, definiremos os m√©todos mostrarPosicao de Coordenada2D e os m√©todos mostrarAtributos de Retangulo e de Circulo.\nCoordenada2D.prototype.mostrarPosicao = function() { return `${this.tipo}na posi√ß√£o (${this.x}, ${this.y})`; }; Retangulo.prototype.mostrarAtributos = function() { return `${this.mostrarPosicao()}com base ${this.base}e altura ${this.altura}`; }; Circulo.prototype.mostrarAtributos = function() { return `${this.mostrarPosicao()}com raio ${this.raio}`; }; let r = new Retangulo(-10, 10, 200, 400); r.mostrarPosicao(); // \u0026#34;Ret√¢ngulo na posi√ß√£o (10, -10)\u0026#34; r.mostrarAtributos(); // \u0026#34;Ret√¢ngulo na posi√ß√£o (10, -10) com base 200 e altura 400\u0026#34;  let c = new Circulo(0, 0, 200); c.mostrarPosicao(); // \u0026#34;C√≠rculo na posi√ß√£o (0, 0)\u0026#34; c.mostrarAtributos(); // \u0026#34;C√≠rculo na posi√ß√£o (0, 0) com raio 200\u0026#34; Inspecionando os objetos r e c, temos:\nRetangulo {tipo: \u0026quot;Ret√¢ngulo\u0026quot;, x: 10, y: -10, base: 200, altura: 400} altura: 400 base: 200 tipo: \u0026quot;Ret√¢ngulo\u0026quot; x: 10 y: -10 __proto__: Coordenada2D mostrarAtributos: ∆í () __proto__: mostrarPosicao: ∆í () constructor: ∆í Coordenada2D(x, y) __proto__: Object Circulo {tipo: \u0026quot;C√≠rculo\u0026quot;, x: 0, y: 0, raio: 200} raio: 200 tipo: \u0026quot;C√≠rculo\u0026quot; x: 0 y: 0 __proto__: Coordenada2D mostrarAtributos: ∆í () __proto__: mostrarPosicao: ∆í () constructor: ∆í Coordenada2D(x, y) __proto__: Object  Implementa√ß√£o com class Entendemos classes como templates para criar objetos. Em JavaScript, classes s√£o fun√ß√µes construtoras com uma propriedade prototype.\nA partir da especifica√ß√£o ECMAScript 2015 (ES6), JavaScript passou a contar com implementa√ß√£o de objetos a partir de classes. Essa sintaxe √© descrita como um a√ß√∫car sint√°tico, uma forma mais \u0026ldquo;simples\u0026rdquo; de implementar objetos com prototype.\nA seguir, replicamos o c√≥digo apresentado previamente implementado com prototype, agora com class.\nclass Coordenada2D { constructor(x, y) { this.tipo = \u0026#34;Coordenada 2D\u0026#34;; this.x = x; this.y = y; } mostrarPosicao() { return `${this.tipo}na posi√ß√£o (${this.x}, ${this.y})`; } } class Retangulo extends Coordenada2D { constructor(x, y, base, altura) { super(x, y); this.tipo = \u0026#34;Ret√¢ngulo\u0026#34;; this.base = base; this.altura = altura; } mostrarAtributos() { return `${this.mostrarPosicao()}com base ${this.base}e altura ${this.altura}`; } } class Circulo extends Coordenada2D { constructor(x, y, raio) { super(x, y); this.tipo = \u0026#34;C√≠rculo\u0026#34;; this.raio = raio; } mostrarAtributos() { return `${this.mostrarPosicao()}com raio ${this.raio}`; } } let r = new Retangulo(-10, 10, 200, 400); r.mostrarPosicao(); // \u0026#34;Ret√¢ngulo na posi√ß√£o (10, -10)\u0026#34; r.mostrarAtributos(); // \u0026#34;Ret√¢ngulo na posi√ß√£o (10, -10) com base 200 e altura 400\u0026#34;  let c = new Circulo(0, 0, 200); c.mostrarPosicao(); // \u0026#34;C√≠rculo na posi√ß√£o (0, 0)\u0026#34; c.mostrarAtributos(); // \u0026#34;C√≠rculo na posi√ß√£o (0, 0) com raio 200\u0026#34; Monkey patch (B√¥nus! ‚≠ê) Monkey patch √© uma t√©cnica usada para estender ou modificar o comportamento de componentes de um sistema de software em tempo de execu√ß√£o.\n ü§ö Cuidado: essa √© uma t√©cnica que deve ser usada com cautela.\n Como exemplo, estenderemos o objeto Array com um novo m√©todo que retorna somente os elementos que forem pares, e modificaremos o m√©todo pop de forma que ele remova todos os elementos de um Array.\n// Adicionar o m√©todo somentePares() ao objeto Array Array.prototype.somentePares = function() { return this.filter(item =\u0026gt; item % 2 === 0); }; const numeros = [1, 1, 2, 3, 5, 8, 13, 21]; numeros.somentePares(); // [2, 8]  // Substituir o m√©todo pop do objeto Array Array.prototype.pop = function() { while (this.length \u0026gt; 0) this.shift(); }; numeros.pop(); // agora numeros √© igual a [] ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/9-programacao-orientada-a-objetos/","summary":"Programa√ß√£o orientada a objetos JavaScript √© uma linguagem de programa√ß√£o baseada em prot√≥tipos (prototype-based language), onde propriedades e m√©todos podem ser compartilhadas entre objetos.\nEm JavaScript, tudo funciona como um objeto, exceto os valores null e undefined. Um erro comum √© acreditar que n√∫meros inteiros (literais) n√£o podem ser usados como objetos, pois o ponto . faz com que o interpretador o interprete como um n√∫mero de ponto flutuante.\n123.toString(); // produz um erro de sintaxe  (123).","title":"Notas de Aulas de JavaScript: 9. Programa√ß√£o Orientada a Objetos"},{"content":"Programa√ß√£o ass√≠ncrona No modelo de execu√ß√£o s√≠ncrono, as instru√ß√µes de um programa s√£o executadas em sequ√™ncia, uma ap√≥s a outra. Nesse modelo, quando uma instru√ß√£o demorada √© executada, o fluxo de execu√ß√£o fica bloqueado, aguardando seu t√©rmino para que as pr√≥ximas instru√ß√µes possam ser executadas.\nNo modelo de execu√ß√£o ass√≠ncrono, √© poss√≠vel executar mais de uma instru√ß√£o ao mesmo tempo. Assim, uma instru√ß√£o demorada poderia ser executada \u0026ldquo;em segundo plano\u0026rdquo;, enquanto o restante das instru√ß√µes continuam normalmente com seu fluxo de execu√ß√£o.\nAlgumas linguagens de programa√ß√£o usam threads para executar c√≥digo ass√≠ncrono. Cada thread funciona como um novo fluxo de execu√ß√£o em um programa.\nEntretanto, JavaSript √© uma linguagem de programa√ß√£o single threaded, mesmo em computadores com m√∫ltiplos cores, um programa JavaScript √© executado em uma √∫nica thread.\nIsso n√£o significa que n√£o seja poss√≠vel executar instru√ß√µes de forma ass√≠ncrona com JavaScript. JavaScript utiliza uma t√©cnica conhecida como event loop, que permite o modelo de execu√ß√£o ass√≠ncrono em uma √∫nica thread.\nMais informa√ß√µes sobre o funcionamento do event loop em https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/EventLoop.\nUm primeiro exemplo No seguinte trecho de c√≥digo, a fun√ß√£o exemplo executa uma instru√ß√£o s√≠ncrona, segioda de uma instru√ß√£o ass√≠ncrona com um callback a partir da fun√ß√£o setTimeout, uma instru√ß√£o ass√≠ncrona com uma Promise, e finalmente, uma √∫ltima instru√ß√£o s√≠ncrona. Observe o resultado:\nfunction exemplo(){ console.log(\u0026#34;S√≠ncrono: In√≠cio\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;Ass√≠ncrono (Callback)\u0026#34;); }); Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;Ass√≠ncrono (Promise)\u0026#34;); }); console.log(\u0026#34;S√≠ncrono: Fim\u0026#34;); } exemplo(); // S√≠ncrono: In√≠cio // S√≠ncrono: Fim // Ass√≠ncrono (Promise) // Ass√≠ncrono (Callback) Callbacks Um callback √© uma fun√ß√£o passada como argumento para outra fun√ß√£o. Dessa forma, a fun√ß√£o que a recebeu pode execut√°-la ou pass√°-la adiante.\nNo exemplo a seguir s√£o declaradas duas fun√ß√µes clicouNoDocumento, usada no evento click do documento, e mostrarMensagem que √© passada para setTimeout para ser executada somente ap√≥s 10 segundos.\nfunction clicouNoDocumento(){ console.log(\u0026#34;Usu√°rio clicou no documento\u0026#34;); } function mostrarMensagem(){ alert(\u0026#34;Ol√°! Tudo bem?\u0026#34;); } // Exemplo 1: chamar a fun√ß√£o clicouNoDocumento quando o documento receber um clique document.addEventListener(\u0026#39;click\u0026#39;, clicouNoDocumento); // Exemplo 2: executar a fun√ß√£o mostrarMensagem ap√≥s 10 segundos setTimeout(mostrarMensagem, 10000); Sequ√™ncia de callbacks executados de forma ass√≠ncrona Nesse exemplo, uma sequ√™ncia de instru√ß√µes setTimeout disparam callbacks que enviam mensagem com console.log, entretanto, devido ao tempo programado em setTimeout, e pelo fato da execu√ß√£o acontecer de forma ass√≠ncrona, a ordem do resultado acontece da √∫ltima para a primeira instru√ß√£o.\nfunction sequenciaDeChanadas_V1(){ setTimeout(function(){ console.log(\u0026#34;Mensagem 1\u0026#34;); }, 1000); setTimeout(function(){ console.log(\u0026#34;Mensagem 2\u0026#34;); }, 800); setTimeout(function(){ console.log(\u0026#34;Mensagem 3\u0026#34;); }, 600); setTimeout(function(){ console.log(\u0026#34;Mensagem 4\u0026#34;); }, 400); setTimeout(function(){ console.log(\u0026#34;Mensagem 5\u0026#34;); }, 200); } sequenciaDeChanadas_V1(); // Mensagem 5 // Mensagem 4 // Mensagem 3 // Mensagem 2 // Mensagem 1 Sequ√™ncia de callbacks executados de forma s√≠ncrona No pr√≥ximo exemplo, as mesmas instru√ß√µes s√£o escritas de forma encadeada, de forma que as instru√ß√µes sejam executadas de forma s√≠ncrona.\nEssa cadeia de instru√ß√µes come√ßa aumentar a complexidade de compreens√£o do c√≥digo, sendo conhecida por alguns como callback hell ou indenta√ß√£o hadouken üòÅ.\nfunction sequenciaDeChamadas_V2(){ setTimeout(function(){ console.log(\u0026#34;Mensagem 1\u0026#34;); setTimeout(function(){ console.log(\u0026#34;Mensagem 2\u0026#34;); setTimeout(function(){ console.log(\u0026#34;Mensagem 3\u0026#34;); setTimeout(function(){ console.log(\u0026#34;Mensagem 4\u0026#34;); setTimeout(function(){ console.log(\u0026#34;Mensagem 5\u0026#34;); }, 200); }, 400); }, 600); }, 800); }, 1000); } sequenciaDeChamadas_V2(); // Mensagem 1 // Mensagem 2 // Mensagem 3 // Mensagem 4 // Mensagem 5 Mesmo com o tempo definido de forma decrescente em setTimeout, cada instru√ß√£o s√≥ inicia ap√≥s o t√©rmino da instru√ß√£o anterior.\nPromises Antes de falar de Promises, vejamos um exemplo de uma requisi√ß√£o AJAX usando o objeto XMLHttpRequest para obter dados da {JSON} Placeholder, uma API fake para testes e prototipa√ß√£o. A URL usada no exemplo √© https://jsonplaceholder.typicode.com/users/1, produzindo a seguinte sa√≠da no formato JSON.\n{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Leanne Graham\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;Bret\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;Sincere@april.biz\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;street\u0026#34;: \u0026#34;Kulas Light\u0026#34;, \u0026#34;suite\u0026#34;: \u0026#34;Apt. 556\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Gwenborough\u0026#34;, \u0026#34;zipcode\u0026#34;: \u0026#34;92998-3874\u0026#34;, \u0026#34;geo\u0026#34;: { \u0026#34;lat\u0026#34;: \u0026#34;-37.3159\u0026#34;, \u0026#34;lng\u0026#34;: \u0026#34;81.1496\u0026#34; } }, \u0026#34;phone\u0026#34;: \u0026#34;1-770-736-8031 x56442\u0026#34;, \u0026#34;website\u0026#34;: \u0026#34;hildegard.org\u0026#34;, \u0026#34;company\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Romaguera-Crona\u0026#34;, \u0026#34;catchPhrase\u0026#34;: \u0026#34;Multi-layered client-server neural-net\u0026#34;, \u0026#34;bs\u0026#34;: \u0026#34;harness real-time e-markets\u0026#34; } } A requisi√ß√£o ser√° feita a partir da fun√ß√£o getUser(id, callback, error), que dado um id ir√° obter o objeto JSON correspondente ao resultado da requisi√ß√£o, que ao terminar, executar√° uma fun√ß√£o callback para lidar com o resultado.\nfunction getUser(id, callback){ const xhr = new XMLHttpRequest(); xhr.onload = function(){ const json = JSON.parse(this.responseText); callback(json); }; const url = `https://jsonplaceholder.typicode.com/users/${id}`; xhr.open(\u0026#34;GET\u0026#34;, url); xhr.send(); } getUser(1, user =\u0026gt; { console.log(user); }); Para ilustrar o uso de Promise, usaremos a Fetch API, para realizar a mesma requisi√ß√£o ass√≠ncrona feita no exemplo anterior.\nA Fetch API oferece uma interface para buscar dados que retorna objetos do tipo Promise, que √© um tipo de objeto usado para o processamento ass√≠ncrono. Observe:\n// Usando callback como par√¢metro function getUser(id, callback){ const URL = `https://jsonplaceholder.typicode.com/users/${id}`; let user; fetch(URL) .then(response =\u0026gt; response.json()) .then(user =\u0026gt; { callback(user); }); } getUser(1, user =\u0026gt; { console.log(user); }); // Usando retorno da Promise e await na chamada function getUser(id){ const URL = `https://jsonplaceholder.typicode.com/users/${id}`; return fetch(URL).then(response =\u0026gt; response.json()); } console.log(await getUser(1)); Sintaxe async / await Uma instru√ß√£o async function define uma fun√ß√£o ass√≠ncrona, que retorna um objeto AsyncFunction, e o operador await √© utilizado para esperar por uma Promise, e deve ser usado dentro de uma async function.\nAgora, realizaremos o mesmo processo dos exemplos anteriores com a sintaxe async / await.\nasync function getUser(id){ const URL = `https://jsonplaceholder.typicode.com/users/${id}`; const response = await fetch(URL); return await response.json(); } console.log(await getUser(1)); Promise.all O m√©todo Promise.all retorna uma √∫nico objeto Promise que resolve quando todos os objetos Promises de seu argumento forem resolvidos. Esses objetos s√£o executados ao mesmo tempo, e quando todos terminarem, seus resultados ser√£o retornados.\nA JSON Placeholder API possui 6 resource endpoists para testes, posts, comments, albums, photos, todos e users. No pr√≥ximo exemplo faremos uma requisi√ß√£o para cada um dos resource endpoints em paralelo atrav√©s de Promise.all.\nconst base_url = \u0026#34;https://jsonplaceholder.typicode.com\u0026#34;; const resource_list = [\u0026#34;posts\u0026#34;, \u0026#34;comments\u0026#34;, \u0026#34;albums\u0026#34;, \u0026#34;photos\u0026#34;, \u0026#34;todos\u0026#34;, \u0026#34;users\u0026#34;]; async function getResource(resource){ const url = `${base_url}/${resource}`; const response = await fetch(url); return await response.json(); } async function getAllResources(){ promises = []; resource_list.forEach(resource =\u0026gt; { promises.push(getResource(resource)); }); return Promise.all(promises); } [posts, comments, albums, photos, todos, users] = await getAllResources(); ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/8-programacao-assincrona/","summary":"Programa√ß√£o ass√≠ncrona No modelo de execu√ß√£o s√≠ncrono, as instru√ß√µes de um programa s√£o executadas em sequ√™ncia, uma ap√≥s a outra. Nesse modelo, quando uma instru√ß√£o demorada √© executada, o fluxo de execu√ß√£o fica bloqueado, aguardando seu t√©rmino para que as pr√≥ximas instru√ß√µes possam ser executadas.\nNo modelo de execu√ß√£o ass√≠ncrono, √© poss√≠vel executar mais de uma instru√ß√£o ao mesmo tempo. Assim, uma instru√ß√£o demorada poderia ser executada \u0026ldquo;em segundo plano\u0026rdquo;, enquanto o restante das instru√ß√µes continuam normalmente com seu fluxo de execu√ß√£o.","title":"Notas de Aulas de JavaScript: 8. Programa√ß√£o Ass√≠ncrona"},{"content":"M√≥dulos CommonJS Os padr√£o de m√≥dulos CommonJS foi (e ainda √©) utilizado pela plataforma Node.js (usada no back-end), portanto ainda √© bastante comum a sua utiliza√ß√£o em projetos com JavaScript, uma vez que o padr√£o ES6 √© relativamente novo, sendo lan√ßado em 2015.\n// index.js const calculadora = require(\u0026#34;./modulo1.js\u0026#34;); const { VERSAO, mensagem } = require(\u0026#34;./modulo2.js\u0026#34;); console.log(\u0026#34;Vers√£o do m√≥dulo:\u0026#34;, VERSAO); console.log(\u0026#34;2+3\u0026#34;, calculadora.somar(2, 3)); console.log(\u0026#34;3-2\u0026#34;, calculadora.subtrair(3, 2)); mensagem(); // modulo1.js module.exports = { somar(a, b) { return a + b; }, subtrair(a, b) { return a - b; } }; // modulo2.js exports.VERSAO = \u0026#34;1.0\u0026#34;; exports.mensagem = function(){ console.log(\u0026#34;Ol√°! Tudo bem?\u0026#34;); } M√≥dulos ES6 O sistema de m√≥dulos introduzido com o ECMAScript 2015 (ES6) possibilita programa√ß√£o modular em arquivos JavaScript com o uso das diretivas import e export, sem a necessidade de vincular todos os arquivos de script no documento HTML.\nPara que um arquivo JavaScript seja carregado como m√≥dulo, √© necess√°rio adicionar o atributo type=\u0026quot;module\u0026quot; √† tag \u0026lt;script\u0026gt; no documento HTML.\nMais informa√ß√µes sobre o funcionamento dos m√≥dulos dispon√≠veis em https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Modules.\n\u0026lt;!-- index.html --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // script.js import calculadora, { VERSAO, mensagem } from \u0026#34;./modulo.js\u0026#34;; console.log(\u0026#34;Vers√£o do m√≥dulo:\u0026#34;, VERSAO); console.log(\u0026#34;2+3\u0026#34;, calculadora.somar(2, 3)); console.log(\u0026#34;3-2\u0026#34;, calculadora.subtrair(3, 2)); mensagem(); // modulo.js export const VERSAO = \u0026#34;1.0\u0026#34;; export function mensagem(){ alert(\u0026#34;Ol√°! Tudo bem?\u0026#34;); } export default { somar(a, b) { return a + b; }, subtrair(a, b) { return a - b; } }; ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/7-modulos/","summary":"M√≥dulos CommonJS Os padr√£o de m√≥dulos CommonJS foi (e ainda √©) utilizado pela plataforma Node.js (usada no back-end), portanto ainda √© bastante comum a sua utiliza√ß√£o em projetos com JavaScript, uma vez que o padr√£o ES6 √© relativamente novo, sendo lan√ßado em 2015.\n// index.js const calculadora = require(\u0026#34;./modulo1.js\u0026#34;); const { VERSAO, mensagem } = require(\u0026#34;./modulo2.js\u0026#34;); console.log(\u0026#34;Vers√£o do m√≥dulo:\u0026#34;, VERSAO); console.log(\u0026#34;2+3\u0026#34;, calculadora.somar(2, 3)); console.log(\u0026#34;3-2\u0026#34;, calculadora.subtrair(3, 2)); mensagem(); // modulo1.js module.exports = { somar(a, b) { return a + b; }, subtrair(a, b) { return a - b; } }; // modulo2.","title":"Notas de Aulas de JavaScript: 7. M√≥dulos"},{"content":"Trabalhando com arrays Obter o tamanho de um Array let cores = [\u0026#34;verde\u0026#34;, \u0026#34;amarelo\u0026#34;, \u0026#34;vermelho\u0026#34;]; let tamanho = cores.length; Acessar um item de um Array let primeira = cores[0]; let ultima = cores[cores.length - 1]; Iterar um Array // usando forEach // cores.forEach(function(item, indice, array) { // console.log(item); // }); cores.forEach(item =\u0026gt; { console.log(item); }); // usando for-of for (let item of cores) { console.log(item); } // usando for for (let i = 0, n = cores.length; i \u0026lt; n; i++){ console.log(cores[i]); } Adicionar e remover itens do Array // adicionar um item no final let tamanhoAposAzul = cores.push(\u0026#34;azul\u0026#34;); // remover um item do final let ultimoRemovido = cores.pop(); // adicionar um item no in√≠cio let tamanhoAposBranco = cores.unshift(\u0026#34;branco\u0026#34;); // remover um item do in√≠cio let primeiroRemovido = cores.shift(); // localizar a posi√ß√£o de um item // retornar√° -1 caso o valor n√£o seja encontrado let posicao = cores.indexOf(\u0026#34;amarelo\u0026#34;); // adicionar 2 itens a partir da posi√ß√£o 2 let posicaoInserir = 2; let itensInserir = [\u0026#34;roxo\u0026#34;, \u0026#34;cinza\u0026#34;]; cores.splice(posicaoInserir, 0, ...itensInserir); // remover 2 itens a partir da posi√ß√£o 2 let posicaoRemover = 2; let quantidadeRemover = 2; let removidos = cores.splice(posicaoRemover, quantidadeRemover); Obter um peda√ßo de um Array const numeros = [1, 1, 2, 3, 5, 8, 13, 21]; const pedaco = numeros.slice(4, 7); // [5, 8, 13] Concatenar Arrays const pares = [2, 4, 6]; const impares = [1, 3, 5]; let novo = pares.concat(impares); // [2, 4, 6, 1, 3, 5] Convers√£o entre Array e String delimitada // criar um array inicial let frutas = [\u0026#34;Laranja\u0026#34;, \u0026#34;Abacate\u0026#34;, \u0026#34;Ma√ß√£\u0026#34;, \u0026#34;Abacaxi\u0026#34;]; // criar uma string delimitada por h√≠fens a partir do array let texto = frutas.join(\u0026#34;-\u0026#34;); // \u0026#34;Laranja-Abacate-Ma√ß√£-Abacaxi\u0026#34;  // modificar a string, \u0026#34;adicionando\u0026#34; novos itens texto += \u0026#34;-Uva-Melancia\u0026#34;; // recriar o array a partir da string delimitada frutas = texto.split(\u0026#39;-\u0026#39;); // [\u0026#34;Laranja\u0026#34;, \u0026#34;Abacate\u0026#34;, \u0026#34;Ma√ß√£\u0026#34;, \u0026#34;Abacaxi\u0026#34;, \u0026#34;Uva\u0026#34;, \u0026#34;Melancia\u0026#34;] Filtrar os itens de um Array function par(valor){ return valor % 2 === 0; } let numeros = [8, 3, 12, -4, 7, -1, 13]; let pares = numeros.filter(par); // de forma alternativa, com \u0026#34;arrow function\u0026#34; pares = numeros.filter(num =\u0026gt; num % 2 === 0); Filtrar os objetos de um Array // itens de uma compra let itens = [ { produto: { descri√ß√£o: \u0026#34;Caf√© torrado mo√≠do 500g\u0026#34;, pre√ßo: 9.5 }, quantidade: 1 }, { produto: { descri√ß√£o: \u0026#34;P√£o de forma integral\u0026#34;, pre√ßo: 7.75 }, quantidade: 2 }, { produto: { descri√ß√£o: \u0026#34;Manteiga com sal 200g\u0026#34;, pre√ßo: 8.0 }, quantidade: 1 }, { produto: { descri√ß√£o: \u0026#34;√Ågua com g√°s 510ml\u0026#34;, pre√ßo: 1.5 }, quantidade: 12 }, { produto: { descri√ß√£o: \u0026#34;Pipoca de microondas\u0026#34;, pre√ßo: 2.5 }, quantidade: 4 } ]; // itens onde a quantidade for maior que 1 let mais_de_1_item = itens .filter((item) =\u0026gt; item.quantidade \u0026gt; 1); // itens onde o valor total (valor unit√°rio * quantidade) for maior que 10 let valor_total_maior_que_10 = itens .filter((item) =\u0026gt; item.produto.pre√ßo * item.quantidade \u0026gt; 10); // itens onde a descri√ß√£o do produto come√ßa com a letra P let descri√ß√£o_come√ßa_com_p = itens .filter((item) =\u0026gt; item.produto.descri√ß√£o[0].toUpperCase() === \u0026#34;P\u0026#34;); Ordenar os itens de um Array let cores = [\u0026#34;verde\u0026#34;, \u0026#34;amarelo\u0026#34;, \u0026#34;vermelho\u0026#34;]; cores.sort(); // [\u0026#34;amarelo\u0026#34;, \u0026#34;verde\u0026#34;, \u0026#34;vermelho\u0026#34;] Inverter a ordem dos itens de um Array let cores = [\u0026#34;verde\u0026#34;, \u0026#34;amarelo\u0026#34;, \u0026#34;vermelho\u0026#34;]; cores.reverse(); // [\u0026#34;vermelho\u0026#34;, \u0026#34;amarelo\u0026#34;, \u0026#34;verde\u0026#34;] Ordenar os objetos de um Array let funcionarios = [ { nome: \u0026#34;Jo√£o\u0026#34;, salario: 3000 }, { nome: \u0026#34;Maria\u0026#34;, salario: 4500 }, { nome: \u0026#34;Ana\u0026#34;, salario: 2500 }, { nome: \u0026#34;Pedro\u0026#34;, salario: 4000 }, { nome: \u0026#34;Paulo\u0026#34;, salario: 2500 } ]; // ordenar por sal√°rio funcionarios.sort((a, b) =\u0026gt; a.salario - b.salario); // ordenar por sal√°rio (decrescente) funcionarios.sort((a, b) =\u0026gt; b.salario - a.salario); // ordenar por nome funcionarios.sort(function(a, b){ if (a.nome \u0026gt; b.nome) return 1; else if (a.nome \u0026lt; b.nome) return -1; else return 0; // iguais }); Transformar os dados de um Array com map /* calcular as taxas correspondentes de um imposto fict√≠cio onde: 10% para valores inferiores a 1000 20% para superiores ou iguais a 1000 e inferiores a 5000 30% para valores superiores ou iguais a 5000 */ function calcularImposto(valor){ if (valor \u0026lt; 1000) return valor * 0.1; // 10%  else if (valor \u0026lt; 5000) return valor * 0.2; // 20%  return valor * 0.3; // 30% } // valores para calcular let valores = [500, 800, 1500, 2500, 5000, 5500, 8000, 10000]; // valores dos impostos let impostos = valores.map(calcularImposto); // valores detalhados: valor, imposto e total let detalhes = valores.map(valor =\u0026gt; { const valor_imposto = calcularImposto(valor); const valor_total = valor + valor_imposto; return { valor: valor, imposto: valor_imposto, total: valor_total }; }); \u0026ldquo;Reduzir\u0026rdquo; os dados de um Array O m√©todo reduce aplica uma fun√ß√£o com um acumulador em cada valor de um Array, do primeiro at√© o √∫ltimo, para reduzi-los a um √∫nico valor.\nA sintaxe do m√©todo reduce com a fun√ß√£o callback √©:\narray.reduce(callback(acumulador, valorAtual, √≠ndice, array), valorInicial); Um exemplo para obter a soma dos n√∫meros que comp√µem um Array:\n// obter a soma dos n√∫meros de um array let numeros = [1, 2, 3, 4, 5]; // let soma = numeros.reduce(function(acumulador, atual, indice, array){ // return acumulador + atual; // }, 0);  let soma = numeros.reduce((acum, atual) =\u0026gt; acum + atual); \u0026ldquo;Reduzir\u0026rdquo; os dados de um Array de objetos // obter a soma dos sal√°rios dos seguintes funcion√°rios let funcionarios = [ { nome: \u0026#34;Jo√£o\u0026#34;, salario: 3000 }, { nome: \u0026#34;Maria\u0026#34;, salario: 4500 }, { nome: \u0026#34;Ana\u0026#34;, salario: 2500 }, { nome: \u0026#34;Pedro\u0026#34;, salario: 4000 }, { nome: \u0026#34;Paulo\u0026#34;, salario: 2500 } ]; // somente com o m√©todo reduce let salariosTotal = funcionarios.reduce((a, b) =\u0026gt; { return { salario: a.salario + b.salario } }).salario; // 16500  // usando os m√©todos map e reduce let salariosTotal_V2 = funcionarios .map(item =\u0026gt; item.salario) .reduce((a, b) =\u0026gt; a + b); // 16500 ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/6-arrays/","summary":"Trabalhando com arrays Obter o tamanho de um Array let cores = [\u0026#34;verde\u0026#34;, \u0026#34;amarelo\u0026#34;, \u0026#34;vermelho\u0026#34;]; let tamanho = cores.length; Acessar um item de um Array let primeira = cores[0]; let ultima = cores[cores.length - 1]; Iterar um Array // usando forEach // cores.forEach(function(item, indice, array) { // console.log(item); // }); cores.forEach(item =\u0026gt; { console.log(item); }); // usando for-of for (let item of cores) { console.log(item); } // usando for for (let i = 0, n = cores.","title":"Notas de Aulas de JavaScript: 6. Arrays"},{"content":"Manipula√ß√£o do HTML DOM O HTML DOM (Document Object Model) √© um modelo de objetos de um documento HTML. O DOM de um documento consiste em uma hierarquia de n√≥s, onde cada n√≥ pode ter, opcionalmente, um n√≥ pai (parent) e n√≥s filhos (children).\nUm elemento do DOM √© um n√≥ que representa uma tag HTML. No DOM, todo elemento (objeto do tipo HTMLElement) √© um n√≥ (objeto do tipo Node), mas nem todo n√≥ √© um elemento, pois existem outros tipos de n√≥s na hierarquia de um documento DOM, como coment√°rios, blocos de texto, a tag especial \u0026lt;!DOCTYPE\u0026gt;, entre outros.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .conteiner { /* definir tamanho e deixar no formato de c√≠rculo */ position: absolute; font-size: 80pt; width: 200px; height: 200px; border: 2px solid black; border-radius: 100px; /* centralizar o conteiner */ left: 50%; top: 50%; transform: translate(-50%, -50%); /* centralizar o conte√∫do interno */ display: flex; align-items: center; justify-content: center; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // definir fun√ß√£o autoexecut√°vel para n√£o sujar o escopo global  (() =\u0026gt; { let contador = 0; const mostrar = () =\u0026gt; { const p = document.querySelector(\u0026#34;#contador\u0026#34;); p.innerText = contador; p.style.color = contador \u0026gt;= 0 ? \u0026#34;blue\u0026#34; : \u0026#34;red\u0026#34;; }; // iniciar o c√≥digo somente ap√≥s o conte√∫do ser carregado  document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { const btnAumentar = document.getElementById(\u0026#34;btnAumentar\u0026#34;); const btnDiminuir = document.getElementById(\u0026#34;btnDiminuir\u0026#34;) // criar fun√ß√µes dos bot√µes  btnAumentar.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { contador++; mostrar(); }); btnDiminuir.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { contador--; mostrar(); }); // disparar o evento click dos bot√µes caso as teclas + ou - sejam usadas  document.addEventListener(\u0026#34;keypress\u0026#34;, event =\u0026gt; { if (event.key === \u0026#34;+\u0026#34;) { btnAumentar.dispatchEvent(new Event(\u0026#34;click\u0026#34;)); } else if (event.key === \u0026#34;-\u0026#34;) { btnDiminuir.dispatchEvent(new Event(\u0026#34;click\u0026#34;)); } }); // criar um elemento onde o contador ser√° exibido  const div = document.createElement(\u0026#34;div\u0026#34;); const p = document.createElement(\u0026#34;p\u0026#34;); div.className = \u0026#34;conteiner\u0026#34;; p.id = \u0026#34;contador\u0026#34;; div.appendChild(p); document.body.appendChild(div); mostrar(); }); })(); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;btnDiminuir\u0026#34;\u0026gt;Diminuir\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;btnAumentar\u0026#34;\u0026gt;Aumentar\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/5-dom/","summary":"Manipula√ß√£o do HTML DOM O HTML DOM (Document Object Model) √© um modelo de objetos de um documento HTML. O DOM de um documento consiste em uma hierarquia de n√≥s, onde cada n√≥ pode ter, opcionalmente, um n√≥ pai (parent) e n√≥s filhos (children).\nUm elemento do DOM √© um n√≥ que representa uma tag HTML. No DOM, todo elemento (objeto do tipo HTMLElement) √© um n√≥ (objeto do tipo Node), mas nem todo n√≥ √© um elemento, pois existem outros tipos de n√≥s na hierarquia de um documento DOM, como coment√°rios, blocos de texto, a tag especial \u0026lt;!","title":"Notas de Aulas de JavaScript: 5. DOM"},{"content":"Estruturas de controle if-else if (condi√ß√£o) instru√ß√£o; if (condi√ß√£o) { instru√ß√£o1; instru√ß√£o2; } if (condi√ß√£o) { instru√ß√£o1; } else { instru√ß√£o2; } if (condi√ß√£o1) { instru√ß√£o1; } else if (condi√ß√£o2) { instru√ß√£o2; } else { instru√ß√£o3; } // exemplo: comparar dois n√∫meros inteiros fornecidos pelo usu√°rio. const n1 = parseInt(prompt(\u0026#34;Por favor, digite um n√∫mero inteiro.\u0026#34;)); const n2 = parseInt(prompt(\u0026#34;Por favor, digite mais um n√∫mero inteiro.\u0026#34;)); let resp; if (n1 \u0026gt; n2) { resp = `${n1}√© maior que ${n2}`; } else if (n1 \u0026gt; n2) { resp = `${n1}√© menor que ${n2}`; } else { resp = `${n1}e ${n2}s√£o iguais`; } alert(resp); switch switch (express√£o) { case valor1: instru√ß√£o1; [break;] case valor2: instru√ß√£o2; [break;] default: instru√ß√£o3; } // exemplo: um conceito para uma nota de 1 a 5 let num = parseInt(prompt(\u0026#34;Por favor, digite um n√∫mero inteiro de 1 a 5\u0026#34;)); switch(num) { case 1: console.log(\u0026#34;Muito ruim\u0026#34;); break; case 2: console.log(\u0026#34;Ruim\u0026#34;); break; case 3: console.log(\u0026#34;Regular\u0026#34;); break; case 4: console.log(\u0026#34;Bom\u0026#34;); break; case 5: console.log(\u0026#34;Muito bom\u0026#34;); break; default: console.log(\u0026#34;N√∫mero fora do intervalo esperado\u0026#34;); } while // while (express√£o) // instru√ß√£o;  // exemplo: listar os n√∫meros de 1 at√© 10 let contador = 1; while (contador \u0026lt;= 10) { console.log(contador); contador++; } do-while // do { // instru√ß√£o; // } while (express√£o);  // exemplo: interromper o loop quando o usu√°rio digitar SAIR let comando; do { comando = window.prompt(\u0026#34;Para terminar, digite SAIR.\u0026#34;); } while (comando !== \u0026#34;SAIR\u0026#34;); for // for (express√£oInicial; condi√ß√£o; express√£oDeIncremento) // instru√ß√£o;  // exemplo: listar os n√∫meros de 1 at√© 10 for (let contador = 1; contador \u0026lt;= 10; contador++) { console.log(contador); } for-in // for (vari√°vel in objeto) // instru√ß√£o;  // exemplo: iterar os atributos de um objeto e mostrar seus valores let objeto = { nome: \u0026#34;Fulano\u0026#34;, email: \u0026#34;fulano@gmail.com\u0026#34; }; for (let atributo in objeto) { console.log(`O atributo ${atributo}tem valor ${objeto[atributo]}`); } for-of // for (vari√°vel of objeto) // instru√ß√£o;  // exemplo: iterar os itens de um array e mostrar seus valores let frutas = [\u0026#34;Laranja\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Abacate\u0026#34;]; for (let item of frutas) { console.log(item); } break // break [r√≥tulo];  // exemplo: interromper o loop quando o usu√°rio digitar SAIR let comando; while(true) { comando = window.prompt(\u0026#34;Para terminar, digite SAIR.\u0026#34;) if (comando === \u0026#34;SAIR\u0026#34;) break; } continue // continue [r√≥tulo];  // somar apenas os n√∫meros pares let i, n, s; for (i = 0, s = 0; i \u0026lt; 10; i++) { n = parseFloat(window.prompt(\u0026#34;Digite um n√∫mero:\u0026#34;)); if (n % 2 == 1) continue; // ir para a pr√≥xima itera√ß√£o  s += n; } console.log(\u0026#34;Soma:\u0026#34;, s); Trabalhando com erros Gerando erros function obterNumero() { const str = prompt(\u0026#34;Por favor, digite um n√∫mero inteiro\u0026#34;); const num = parseInt(str); if (isNaN(num)) { throw \u0026#34;N√∫mero inv√°lido\u0026#34;; } else { return num; } } Verificando erros try { const n1 = obterNumero(); const n2 = obterNumero(); const resp = n1 + n2; // gerar um erro caso o resultado seja negativo  if (resp \u0026lt; 0) throw \u0026#34;Resultado negativo\u0026#34;; console.log(`${n1}+ ${n2}= ${resp}`); } catch(err) { console.error(err); } finally { console.log(\u0026#34;Fim da execu√ß√£o\u0026#34;); } ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/4-estruturas-de-controle/","summary":"Estruturas de controle if-else if (condi√ß√£o) instru√ß√£o; if (condi√ß√£o) { instru√ß√£o1; instru√ß√£o2; } if (condi√ß√£o) { instru√ß√£o1; } else { instru√ß√£o2; } if (condi√ß√£o1) { instru√ß√£o1; } else if (condi√ß√£o2) { instru√ß√£o2; } else { instru√ß√£o3; } // exemplo: comparar dois n√∫meros inteiros fornecidos pelo usu√°rio. const n1 = parseInt(prompt(\u0026#34;Por favor, digite um n√∫mero inteiro.\u0026#34;)); const n2 = parseInt(prompt(\u0026#34;Por favor, digite mais um n√∫mero inteiro.\u0026#34;)); let resp; if (n1 \u0026gt; n2) { resp = `${n1}√© maior que ${n2}`; } else if (n1 \u0026gt; n2) { resp = `${n1}√© menor que ${n2}`; } else { resp = `${n1}e ${n2}s√£o iguais`; } alert(resp); switch switch (express√£o) { case valor1: instru√ß√£o1; [break;] case valor2: instru√ß√£o2; [break;] default: instru√ß√£o3; } // exemplo: um conceito para uma nota de 1 a 5 let num = parseInt(prompt(\u0026#34;Por favor, digite um n√∫mero inteiro de 1 a 5\u0026#34;)); switch(num) { case 1: console.","title":"Notas de Aulas de JavaScript: 4. Estruturas de Controle"},{"content":"Escopo, Vari√°veis e Fun√ß√µes valor1 = 1; // escopo global var valor2 = 12; // escopo de fun√ß√£o let valor3 = 123; // escopo de bloco const valor4 = 1234; // escopo de bloco  // n√£o √© poss√≠vel alterar o valor de uma constante Escopo global valor1 = 1; function func1() { valor1 = 2; { valor1 = 3; console.log(\u0026#34;func1 \u0026gt;\u0026gt; {} \u0026gt;\u0026gt; valor1:\u0026#34;, valor1); // 3  } console.log(\u0026#34;func1 \u0026gt;\u0026gt; valor1:\u0026#34;, valor1); // 3 } func1(); console.log(\u0026#34;valor1:\u0026#34;, valor1); // 3 Escopo de fun√ß√£o var val2 = 1; function func2() { var val2 = 2; { var val2 = 3; console.log(\u0026#34;func2 \u0026gt;\u0026gt; {} \u0026gt;\u0026gt; val2:\u0026#34;, val2); // 3  } console.log(\u0026#34;func2 \u0026gt;\u0026gt; val2:\u0026#34;, val2); // 3 } func2(); console.log(\u0026#34;val2:\u0026#34;, val2); // 1 Escopo de bloco let val3 = 1; const con3 = 1; function func3() { let val3 = 2; const con3 = 2; { let val3 = 3; const con3 = 3; console.log(\u0026#34;func3 \u0026gt;\u0026gt; {} \u0026gt;\u0026gt; val3, con3:\u0026#34;, val3, con3); // 3 3  } console.log(\u0026#34;func3 \u0026gt;\u0026gt; val3:\u0026#34;, val3, con3); // 2 2 } func3(); console.log(\u0026#34;val3, con3:\u0026#34;, val3, con3); // 1 1 Fun√ß√µes Declara√ß√£o de fun√ß√µes, argumentos e retorno // uma fun√ß√£o que ao ser executada imprime uma mensagem function ola() { console.log(\u0026#34;Ol√°! Tudo bem?\u0026#34;); } ola(); // imprime \u0026#34;Ol√°! Tudo bem?\u0026#34;  // uma fun√ß√£o que recebe um valor como par√¢metro // e imprime uma mensagem com esse valor function ola_v2(nome) { console.log(\u0026#34;Ol√°\u0026#34;, nome); } ola_v2(\u0026#34;Fulano\u0026#34;); // imprime \u0026#34;Ol√° Fulano\u0026#34;  // uma fun√ß√£o que recebe dois valores como par√¢metros // e retorna o valor da soma desses dois valores function soma(num1, num2) { return num1 + num2; } resp = soma(12, 21); // resp vale 33 Fun√ß√µes an√¥nimas // a vari√°vel soma2 recebe como valor uma fun√ß√£o // que recebe dois valores como par√¢metros // e que retorna como valor a soma desses dois par√¢metros soma_v2 = function(num1, num2) { return num1 + num2; } resp = soma_v2(1, 10); // resp vale 11 Arrow functions // exemplo similar ao anterior // a declara√ß√£o √© feita com a sintaxe conhecida como *arrow function* soma_v3 = (num1, num2) =\u0026gt; { return num1 + num2; } resp = soma_v3(2, 20); // resp vale 22  // exemplo similar ao anterior // arrows functions sem as chaves {} retornam o valor de sua express√£o soma_v4 = (num1, num2) =\u0026gt; num1 + num2; resp = soma_v4(5, 10); // resp vale 15  // arrows function com apenas um argumento dispensam par√™nteses dobro = num =\u0026gt; 2 * num; resp = dobro(8); // resp vale 16 Observa√ß√£o: Arrow functions n√£o possuem this e n√£o devem ser usadas como m√©todos.\nM√©todos let pessoa = { nome: \u0026#34;Fulano\u0026#34;, sobrenome: \u0026#34;Silva\u0026#34;, // nomeCompleto: function(){  // return `${this.nome} ${this.sobrenome}`;  // }  nomeCompleto(){ return `${this.nome}${this.sobrenome}`; } }; console.log(pessoa.nomeCompleto()); Fun√ß√µes autoexecut√°veis (function(){ console.log(\u0026#34;Mensagem da fun√ß√£o.\u0026#34;); })(); (function(){ console.log(\u0026#34;Mensagem da fun√ß√£o.\u0026#34;); }()); (()=\u0026gt;{ console.log(\u0026#34;Mensagem da fun√ß√£o.\u0026#34;); })(); (()=\u0026gt;{ console.log(\u0026#34;Mensagem da fun√ß√£o.\u0026#34;); }()); Preservar o escopo global de um documento HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;btnAumentar\u0026#34;\u0026gt;Aumentar\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;btnDiminuir\u0026#34;\u0026gt;Diminuir\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;btnMostrar\u0026#34;\u0026gt;Mostrar\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; (function(){ let numero = 0; const aumentar = function() { numero = numero + 10; mostrar(); } const diminuir = function() { numero = numero - 10; mostrar(); } const mostrar = function() { console.log(numero); } document.getElementById(\u0026#34;btnAumentar\u0026#34;).onclick = aumentar; document.getElementById(\u0026#34;btnDiminuir\u0026#34;).onclick = diminuir; document.getElementById(\u0026#34;btnMostrar\u0026#34;).onclick = mostrar; mostrar(); })(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/3-escopo-variaveis-e-funcoes/","summary":"Escopo, Vari√°veis e Fun√ß√µes valor1 = 1; // escopo global var valor2 = 12; // escopo de fun√ß√£o let valor3 = 123; // escopo de bloco const valor4 = 1234; // escopo de bloco  // n√£o √© poss√≠vel alterar o valor de uma constante Escopo global valor1 = 1; function func1() { valor1 = 2; { valor1 = 3; console.log(\u0026#34;func1 \u0026gt;\u0026gt; {} \u0026gt;\u0026gt; valor1:\u0026#34;, valor1); // 3  } console.","title":"Notas de Aulas de JavaScript: 3. Escopo, Vari√°veis e Fun√ß√µes"},{"content":"Coment√°rios JavaScript possui coment√°rios de linha e coment√°rios de bloco. Os coment√°rios de linha s√£o definidos ap√≥s duas barras //. Dessa forma, todo o conte√∫do ap√≥s as duas barras // √© considerado coment√°rio e n√£o ser√° interpretado como c√≥digo.\n// Este √© um coment√°rio de linha numero = 0; // Atribuir o valor 0 a vari√°vel numero J√° os coment√°rios de bloco s√£o definidos entre as sequ√™ncias /* e */. Assim, todo o conte√∫do entre as sequ√™ncias /* e */ √© um bloco de coment√°rio e n√£o ser√° interpretado como c√≥digo.\n/* Este √© um coment√°rio de bloco. Ele pode ter v√°rias linhas. √â bastante √∫til para trechos de documenta√ß√£o de c√≥digo. */ Entrada e sa√≠da b√°sica no navegador Os navegadores de internet possuem alguns m√©todos √∫teis para a realiza√ß√£o de testes durante o aprendizado da linguagem, como console.log, console.warn e console.error, que produzem sa√≠das no console das ferramentas do desenvolvedor, e os m√©todos prompt, alert e confirm, do objeto window que permitem entrada e sa√≠da b√°sica a partir de janelas pop-ups.\n// obter uma string do usu√°rio a partir de uma janela *pop-up* nome = window.prompt(\u0026#34;Digite seu nome:\u0026#34;); // enviar uma mensagem ao usu√°rio por uma janela *pop-up* window.alert(\u0026#34;Ol√° \u0026#34; + nome); // obter uma confirma√ß√£o do usu√°rio (Ok/Cancelar) por uma janela *pop-up* resposta = window.confirm(\u0026#34;Tem certeza?\u0026#34;) // exibir uma mensagem ao usu√°rio no console do desenvolvedor (F12) // ver tamb√©m: console.error, console.warn, console.info, console.table, ... console.log(\u0026#34;Ol√°\u0026#34;, nome); Tipos de dados primitivos  Boolean: os valores true e false. null: indica um valor nulo. undefined: indica um valor indefinido. Number: n√∫meros inteiros e reais, ex: 10.05, 0, -1, 3.14. String: cadeia de caracteres (texto), ex: \u0026ldquo;Um texto!\u0026rdquo;. Symbol: (Novo no EcmaScript 6) Tipo com inst√¢ncias √∫nicas e imut√°veis, pode ser usado, por exemplo, em chaves de objetos.  typeof true; // \u0026#34;boolean\u0026#34; typeof null; // \u0026#34;object\u0026#34; typeof undefined; // \u0026#34;undefined\u0026#34; typeof 123; // \u0026#34;number\u0026#34; typeof 1.5; // \u0026#34;number typeof \u0026#34;abc\u0026#34;; // \u0026#34;string\u0026#34; typeof \u0026#39;abc\u0026#39;; // \u0026#34;string\u0026#34; typeof {}; // \u0026#34;object\u0026#34; typeof []; // \u0026#34;object\u0026#34; Opera√ß√µes diversas Aritm√©tica b√°sica 123 + 321; // adi√ß√£o: 123 mais 321 igual a 444 98 ‚Äì 87; // subtra√ß√£o: 98 menos 87 igual a 11 5 * 2; // multiplica√ß√£o: 5 vezes 2 igual a 10 12 / 4; // divis√£o: 12 dividido por 4 igual a 3 5 % 2; // resto da divis√£o: 5 dividido por 2 sobra 1 4 ** 3; // pot√™ncia: 4 elevado a 3 igual a 64 Atribui√ß√£o simples a = 1; // atribui√ß√£o: a recebe 1 b = a + 2; // atribui√ß√£o: b recebe valor de a mais 2 Atribui√ß√£o aritm√©tica x = 1; // atribui√ß√£o simples: x recebe 1 x += 10; // x recebe valor de x mais 10 ... x = 11 x *= 2; // x recebe valor de x vezes 2 ... x = 22 Incrementadores/decrementadores x = 0; // atribui√ß√£o simples: x recebe 0 x++; // x agora vale 1 x++; // x agora vale 2 x--; // x agora vale 1  y = x++; // y vale 1 e x vale 2 y = ++x; // y e x valem 3 Concatena√ß√£o de Strings nome = \u0026#34;Fulano\u0026#34;; linguagem = \u0026#34;Java\u0026#34; + \u0026#34;Script\u0026#34;; // \u0026#34;JavaScript\u0026#34; frase = nome + \u0026#34; programa em \u0026#34; + linguagem; // \u0026#34;Fulano programa em JavaScript\u0026#34;  // usando interpola√ß√£o com \u0026#34;template string\u0026#34; outra_frase = `${nome}programa em ${linguagem}`; Uso de par√™nteses // media recebe a soma de 9, 8, 7 e 6 dividida por 4 // ou, media recebe a m√©dia aritm√©tica de 9, 8, 7 e 6 media = (9 + 8 + 7 + 6) / 4; Compara√ß√£o de valores a == b; // comparar se o valor de a √© igual ao valor de b a != 0; // comparar se o valor de a √© diferente de 0 b \u0026gt; c; // comparar se o valor de b √© maior que o valor de c c \u0026lt; d; // comparar se o valor de c √© menor que o valor de d a \u0026lt;= 1; // comparar se o valor de a √© menor ou igual a 1 9 \u0026gt;= b; // comparar se 9 √© maior ou igual ao valor de b  a === b; // comparar se a e b tem o mesmo valor e o mesmo tipo a !== b; // comparar se a e b n√£o tem mesmo valor e mesmo tipo  1 == \u0026#34;1\u0026#34;; // true 1 != \u0026#34;1\u0026#34;; // false 1 === \u0026#34;1\u0026#34;; // false 1 !== \u0026#34;1\u0026#34;; // true Operadores l√≥gicos // and true \u0026amp;\u0026amp; true; // true true \u0026amp;\u0026amp; false; // false false \u0026amp;\u0026amp; true; // false false \u0026amp;\u0026amp; false; // false  // or true || true; // true true || false; // true false || true; // true false || false; // false  // not !true; // false !false; // true  !0; // true !1; // false !\u0026#34;\u0026#34;; // true !!\u0026#34;\u0026#34;; // false !\u0026#34;asdf\u0026#34;; // false !!\u0026#34;asdf\u0026#34;; // true  // busca por um valor \u0026#34;verdadeiro\u0026#34; nome = \u0026#34;\u0026#34;; sobrenome = \u0026#34;\u0026#34;; usuario = \u0026#34;admin\u0026#34;; console.log(nome || sobrenome || usuario || \u0026#34;visitante\u0026#34;); // \u0026#34;admin\u0026#34; Objetos Um objeto √© uma lista de pares de nomes associados a valores. Pode-se usar um inicializador literal com {} ou o construtor Object.\ncontato1 = { nome: \u0026#34;Fulano\u0026#34;, email: \u0026#34;fulano@gmail.com\u0026#34; }; console.log(\u0026#34;O e-mail de\u0026#34;, contato1.nome, \u0026#34;√©\u0026#34;, contato1.email); contato2 = {}; contato2.nome = \u0026#34;Cicrano\u0026#34;; contato2.email = \u0026#34;cicrano@live.com\u0026#34;; console.log(`O e-mail de ${contato2.nome}√© ${contato2.email}`); contato3 = new Object(); contato3[\u0026#34;nome\u0026#34;] = \u0026#34;Beltrano\u0026#34;; // atributo como string entre colchetes [] contato3.email = \u0026#34;beltrano@hotmail.com\u0026#34;; console.log(`O e-mail de ${contato3.nome}√© ${contato[\u0026#34;email\u0026#34;]}`); Arrays Tecnicamente, em JavaScript, um Array √© considerado um objeto com caracter√≠sticas distintas. √â definido como uma lista com zero ou mais valores indexados iniciando em zero.\nfrutas = [\u0026#34;Laranja\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Abacate\u0026#34;]; console.log(frutas[0], \u0026#34;√© uma √≥tima fruta.\u0026#34;); // Laranja √© uma √≥tima fruta. Convers√£o autom√°tica entre tipos valor = \u0026#34;10\u0026#34; + \u0026#34;5\u0026#34;; // concatena√ß√£o: \u0026#34;105\u0026#34; valor = \u0026#34;10\u0026#34; + 5; // concatena√ß√£o: \u0026#34;105\u0026#34; valor = 10 + \u0026#34;5\u0026#34;; // concatena√ß√£o: \u0026#34;105\u0026#34; valor = \u0026#34;10\u0026#34; ‚Äì 5; // subtra√ß√£o: 5 ¬Ø\\_(„ÉÑ)_/¬Ø valor = \u0026#34;10\u0026#34; * 5; // multiplica√ß√£o: 50 Convers√£o entre String e Number // convers√£o para n√∫meros inteiros a = \u0026#34;10\u0026#34;; b = \u0026#34;-2\u0026#34;; parseInt(a) + parseInt(b); // convers√£o para base decimal parseInt(\u0026#34;1234\u0026#34;, 8); // octal para decimal parseInt(\u0026#34;10001\u0026#34;, 2); // bin√°rio para decimal  // convers√£o para n√∫meros reais a = \u0026#34;1.5\u0026#34;; b = \u0026#34;2.75\u0026#34;; parseFloat(a) + parseFloat(b); // forma alternativa de convers√£o de texto para n√∫meros (sinal +) a = \u0026#34;2.5\u0026#34;; b = \u0026#34;4\u0026#34;; +\u0026#34;1.5\u0026#34; + +\u0026#34;4\u0026#34; + +a; (+a) + (+b) + (+\u0026#34;1.1\u0026#34;); // CUIDADO!!! x = \u0026#34;\u0026#34;; parseInt(x); // NaN +x; // 0 ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/2-sintaxe-basica-tipos-e-operadores/","summary":"Coment√°rios JavaScript possui coment√°rios de linha e coment√°rios de bloco. Os coment√°rios de linha s√£o definidos ap√≥s duas barras //. Dessa forma, todo o conte√∫do ap√≥s as duas barras // √© considerado coment√°rio e n√£o ser√° interpretado como c√≥digo.\n// Este √© um coment√°rio de linha numero = 0; // Atribuir o valor 0 a vari√°vel numero J√° os coment√°rios de bloco s√£o definidos entre as sequ√™ncias /* e */. Assim, todo o conte√∫do entre as sequ√™ncias /* e */ √© um bloco de coment√°rio e n√£o ser√° interpretado como c√≥digo.","title":"Notas de Aulas de JavaScript: 2. Sintaxe B√°sica, Tipos e Operadores"},{"content":"Breve hist√≥ria JavaScript foi criada em 1995 por Brendan Eich enquanto ele trabalhava para a Netscape implementando a linguagem no navegador da empresa, o Netscape Navigator.\nInicialmente, o nome da linguagem passou por algumas mudan√ßas, como Mocha e LiveScript at√© chegar no seu nome atual, o JavaScript.\nAtualmente, a linguagem √© chamada, em sua padroniza√ß√£o, de ECMAScript, e n√£o JavaScript. Essa diferen√ßa se d√° pelo fato de que JavaScript √© uma marca registrada pela ent√£o Sun, posteriormente adquirida pela Oracle.\nPadroniza√ß√£o Existem dois padr√µes para JavaScript, o ECMA-262, seu padr√£o principal, e o ISO/IEC 16262, um padr√£o secund√°rio.\nAtualmente, a linguagem de programa√ß√£o ECMAScript √© padronizada pelo Ecma International Commitee 39, o TC39.\nO TC39 √© um comit√™ composto por membros, especialmente empresas concorrentes, como Apple, Facebook, Google, Microsoft, entre outras, trabalhando juntos pelo bem da linguagem.\nTodas as reuni√µes do TC39 est√£o documentadas em um reposit√≥rio do GitHub: https://github.com/tc39/notes.\nJavaScript no front-end  O c√≥digo JavaScript √© inserido em um documento HTML, atrav√©s de um elemento \u0026lt;script\u0026gt;; O c√≥digo pode estar em um arquivo separado do documento HTML e ser referenciado a partir do atributo src=\u0026quot;nome-do-arquivo.js\u0026quot;; O c√≥digo tamb√©m pode ser definido como conte√∫do do pr√≥prio elemento \u0026lt;script\u0026gt;; Uma outra forma √© importar o c√≥digo como um m√≥dulo; Recomenda-se o uso das \u0026ldquo;ferramentas do desenvolvedor\u0026rdquo; (F12) em um navegador moderno (Chrome, Firefox).  JavaScript no back-end  Node.js √© uma runtime de JavaScript ass√≠ncrona orientada a eventos; Node.js permite execu√ß√£o de c√≥digo JavaScript no back-end; Npm √© o gerenciador de depend√™ncia oficial do Node.js; Yarn √© um popular gerenciador de depend√™ncias concorrente do Npm, criado pela Facebook; Deno √© uma runtime de JavaScript e TypeScript projetada para ser simples e segura; Deno √© um projeto recente e foi criado por Ryan Dahl, o mesmo criador do Node.js;  Ferramentas de desenvolvimento  Visual Studio Code  Code Runner ESLint Quokka Debugger for Chrome Debugger for Firefox   Navegador  Firefox Developer Edition Chrome Dev Ferramentas do Desenvolvedor   Node.js  ","permalink":"https://fabioboris.com.br/posts/notas-de-aulas/javascript/1-introducao/","summary":"Breve hist√≥ria JavaScript foi criada em 1995 por Brendan Eich enquanto ele trabalhava para a Netscape implementando a linguagem no navegador da empresa, o Netscape Navigator.\nInicialmente, o nome da linguagem passou por algumas mudan√ßas, como Mocha e LiveScript at√© chegar no seu nome atual, o JavaScript.\nAtualmente, a linguagem √© chamada, em sua padroniza√ß√£o, de ECMAScript, e n√£o JavaScript. Essa diferen√ßa se d√° pelo fato de que JavaScript √© uma marca registrada pela ent√£o Sun, posteriormente adquirida pela Oracle.","title":"Notas de Aulas de JavaScript: 1. Introdu√ß√£o"}]